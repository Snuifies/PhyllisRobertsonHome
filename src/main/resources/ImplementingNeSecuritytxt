https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter


Spring Boot 2 features
--------------------------------

To Enable Spring Security add the dependency to your pom.xml

        <dependency> 
            <groupId>org.springframework.boot</groupId> 
            <artifactId>spring-boot-starter-security</artifactId> 
        </dependency> 

Some features:

In Spring Boot 2, form authentication has become the default choice

In Spring Boot 2: WebSecurityConfigurerAdapter is deprecated and it is recommended to use a SecurityFilterChain

If you do not specifiy credentials in 
-----------------------------------
- the properties files 
- or using SecurityConfiguration 
- or using SecurityFilterChain 

Spring boot will create a password for you every time the application starts.
the userid: user
the password is given in the console:

Look for: 
Using generated security password: 37d8f13b-71fa-4a66-88c0-54906742d52d
This generated password is for development use only. Your security configuration must be updated before running your application in production.

If you specify credentials is the properties file:
----------------------------------------------------
the keys of some of the Boot properties have changed:
    server.tomcat.access_log_enabled has been renamed into server.tomcat.accesslog.enabled
    security.user.name has been renamed into spring.security.user.name
    security.user.password has been renamed into spring.security.user.password
    security.basic.authorize-mode has been removed
    security.basic.path has been removed


In Spring Boot 2, it's required to specify the password encryption. You need to create a PasswordEncoder bean.

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

and use it to encrypt the passwords when defining the user credentials: 

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth.
        inMemoryAuthentication().passwordEncoder(passwordEncoder()).
        withUser("user").password(passwordEncoder().encode("pass")).
        roles("USER");
}

From  Spring Security 5.7 (used in Spring boot 2) the correct way to confiogure Web Security is to:

Register a SecurityFilterChain Bean:
-----------------------------------
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((authz) -> authz
                .anyRequest().authenticated()
            )
            .httpBasic(withDefaults());
        return http.build();
    }
}

Register a WebSecurityCustomizer Bean :
----------------------------------------
@Configuration
public class SecurityConfiguration {

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (web) -> web.ignoring().antMatchers("/ignore1", "/ignore2");
    }
}

For JDBC Authentication : registerg a JdbcUserDetailsManager bean:
-------------------------------------------------------------------
@Configuration
public class SecurityConfiguration {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
            .build();
    }

    @Bean
    public UserDetailsManager users(DataSource dataSource) {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
        users.createUser(user);
        return users;
    }
}

For In-Memory Authentication : registerg a InMemoryUserDetailsManager bean:
-----------------------------------------------------------------------------
@Configuration
public class SecurityConfiguration {
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        return new InMemoryUserDetailsManager(user);
    }
}

For LDAP Authentication : use the new LDAP classes:
-----------------------------------------------------------------------------
@Configuration
public class SecurityConfiguration {
    @Bean
    public EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {
        EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean =
            EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();
        contextSourceFactoryBean.setPort(0);
        return contextSourceFactoryBean;
    }

    @Bean
    AuthenticationManager ldapAuthenticationManager(
            BaseLdapPathContextSource contextSource) {
        LdapBindAuthenticationManagerFactory factory = 
            new LdapBindAuthenticationManagerFactory(contextSource);
        factory.setUserDnPatterns("uid={0},ou=people");
        factory.setUserDetailsContextMapper(new PersonContextMapper());
        return factory.createAuthenticationManager();
    }
}


Global AuthenticationManager

To create an AuthenticationManager that is available to the entire application you can simply register the AuthenticationManager as a @Bean.

This type of configuration is shown above in the LDAP Authentication example.
Local AuthenticationManager

In Spring Security 5.6 we introduced the method HttpSecurity#authenticationManager that overrides the default AuthenticationManager for a specific SecurityFilterChain.
Below is an example configuration that sets a custom AuthenticationManager as the default:

@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((authz) -> authz
                .anyRequest().authenticated()
            )
            .httpBasic(withDefaults())
            .authenticationManager(new CustomAuthenticationManager());
        return http.build();
    }

}

Accessing the local AuthenticationManager

The local AuthenticationManager can be accessed in a custom DSL. This is actually how Spring Security internally implements methods like HttpSecurity.authorizeRequests().

public class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> {
    @Override
    public void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);
        http.addFilter(new CustomFilter(authenticationManager));
    }

    public static MyCustomDsl customDsl() {
        return new MyCustomDsl();
    }
}

The custom DSL can then be applied when building the SecurityFilterChain:

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    // ...
    http.apply(customDsl());
    return http.build();
}


Solving the AuthenticationManager error
-----------------------------------------------

@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
return authenticationConfiguration.getAuthenticationManager();
}